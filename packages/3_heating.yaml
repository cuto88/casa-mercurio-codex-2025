# ===============================
# FILE: config/packages/3_heating.yaml
# ===============================
###############################################################################
# Riscaldamento a pavimento — logica, helper e automazioni
# Sensori reali: sensor.t_in_giorno, _notte1, _notte2, _bagno, sensor.t_out
###############################################################################

# ---------------------------------------------------------------------------
# PERSONALIZZAZIONI
# ---------------------------------------------------------------------------
homeassistant:
  customize:
    switch.4_ch_interrutore_3:
      friendly_name: "Riscaldamento — Interruttore Generale"
      icon: mdi:radiator

# ---------------------------------------------------------------------------
# TOGGLE DI ZONA + OVERRIDE
# ---------------------------------------------------------------------------
input_boolean:
  # Inclusione delle stanze nel calcolo
  heating_use_giorno:
    name: Usa Zona Giorno
    icon: mdi:home
  heating_use_notte1:
    name: Usa Notte1
    icon: mdi:bed
  heating_use_notte2:
    name: Usa Notte2
    icon: mdi:bed
  heating_use_bagno:
    name: Usa Bagno
    icon: mdi:shower

  # Logica generale e override
  heating_enable:
    name: Abilita logica riscaldamento
    icon: mdi:radiator
  heating_force_on:
    name: Forza ON (override)
    icon: mdi:flash
  heating_force_off:
    name: Forza OFF (override)
    icon: mdi:cancel
  heating_manual_active:
    name: Modalità manuale attiva
    icon: mdi:hand-back-right

input_select:
  heating_manual_mode:
    name: Riscaldamento — Modalità manuale
    options: ["ON", "OFF"]
    icon: mdi:tune-variant
    initial: "ON"

# ---------------------------------------------------------------------------
# PARAMETRI / SOGLIE
# ---------------------------------------------------------------------------
input_number:
  temp_target_risc:
    name: Target comfort (°C)
    min: 18
    max: 23
    step: 0.1
    unit_of_measurement: "°C"
    icon: mdi:home-thermometer
  heating_tolerance:
    name: Isteresi sotto-target (°C)
    min: 0.2
    max: 1.0
    step: 0.1
    unit_of_measurement: "°C"
    icon: mdi:axis-x-arrow
  heating_ext_cold_threshold:
    name: Soglia esterna "freddo" (°C)
    min: -10
    max: 20
    step: 0.5
    unit_of_measurement: "°C"
    icon: mdi:snowflake
  heating_min_on_minutes:
    name: Min ON (min)
    min: 5
    max: 120
    step: 5
    unit_of_measurement: "min"
    icon: mdi:timer-play
  heating_min_off_minutes:
    name: Min OFF (min)
    min: 5
    max: 120
    step: 5
    unit_of_measurement: "min"
    icon: mdi:timer-off
  heating_hours_on_daily:
    name: "Riscaldamento — Ore ON / giorno"
    unit_of_measurement: "h"
    min: 0
    max: 24
    step: 0.1
    icon: mdi:timeline-clock

input_datetime:
  heating_window_start:
    name: Fascia start (orario)
    has_time: true
    has_date: false
  heating_window_end:
    name: Fascia end (orario)
    has_time: true
    has_date: false

# ---------------------------------------------------------------------------
# TIMER
# ---------------------------------------------------------------------------
timer:
  heating_manual_timeout:
    name: Riscaldamento — Timeout manuale
    duration: "01:00:00"

# ---------------------------------------------------------------------------
# TEMPLATE (SENSORI E BINARI)
# ---------------------------------------------------------------------------
template:
  - sensor:
      # Elenco delle stanze attive (solo quelle abilitate)
      - name: "Heating — stanze attive"
        unique_id: heating_rooms_active
        object_id: heating_stanze_attive
        availability: "true"
        state: >-
          {% set rooms = [
            ('Zona Giorno', 'sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
            ('Notte1', 'sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
            ('Notte2', 'sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
            ('Bagno', 'sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
          ] %}
          {% set active = [] %}
          {% for label, sid, tog in rooms %}
            {% if is_state(tog, 'on') %}
              {% set active = active + [label] %}
            {% endif %}
          {% endfor %}
          {{ active | join(', ') if active | length > 0 else 'Nessuna (⚠️)' }}

      # Temperatura interna minima fra le stanze attive
      - name: "Heating — T interna minima"
        unique_id: heating_t_in_min
        object_id: heating_t_interna_minima
        unit_of_measurement: "°C"
        device_class: temperature
        availability: >-
          {% set rooms = [
            ('sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
            ('sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
            ('sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
            ('sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
          ] %}
          {% set vals = [] %}
          {% for sid, tog in rooms %}
            {% set ent = states.get(sid) %}
            {% if is_state(tog, 'on') and ent is not none and ent.state not in ['unknown', 'unavailable', ''] %}
              {% set vals = vals + [ent.state | float] %}
            {% endif %}
          {% endfor %}
          {{ vals | length > 0 }}
        state: >-
          {% set rooms = [
            ('sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
            ('sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
            ('sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
            ('sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
          ] %}
          {% set vals = [] %}
          {% for sid, tog in rooms %}
            {% set ent = states.get(sid) %}
            {% if is_state(tog, 'on') and ent is not none and ent.state not in ['unknown', 'unavailable', ''] %}
              {% set vals = vals + [ent.state | float] %}
            {% endif %}
          {% endfor %}
          {% if vals | length > 0 %}{{ (vals | min) | round(2) }}{% else %}unknown{% endif %}

      # Numero stanze conteggiate e quante sono sotto-target
      - name: "Heating — stanze sotto target"
        unique_id: heating_rooms_below_target
        object_id: heating_rooms_below_target
        unit_of_measurement: "stanze"
        availability: >-
          {{ states('input_number.temp_target_risc') not in ['unknown', 'unavailable', '']
             and states('input_number.heating_tolerance') not in ['unknown', 'unavailable', ''] }}
        state: >-
          {% set rooms = [
            ('sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
            ('sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
            ('sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
            ('sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
          ] %}
          {% set t_target = states('input_number.temp_target_risc') | float(21) %}
          {% set tol = states('input_number.heating_tolerance') | float(0.5) %}
          {% set below = [] %}
          {% for sid, tog in rooms %}
            {% set ent = states.get(sid) %}
            {% if is_state(tog, 'on') and ent is not none and ent.state not in ['unknown', 'unavailable', ''] %}
              {% if ent.state | float < (t_target - tol) %}
                {% set below = below + [sid] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ below | length }}
        attributes:
          stanze_conteggiate: >-
            {% set rooms = [
              ('sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
              ('sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
              ('sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
              ('sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
            ] %}
            {% set count = 0 %}
            {% for sid, tog in rooms %}
              {% set ent = states.get(sid) %}
              {% if is_state(tog, 'on') and ent is not none and ent.state not in ['unknown', 'unavailable', ''] %}
                {% set count = count + 1 %}
              {% endif %}
            {% endfor %}
            {{ count }}

      # Minuti dall'ultimo cambio dello switch generale (ON↔OFF)
      - name: "Heating — minuti da ultimo cambio"
        unique_id: heating_minutes_since_change
        object_id: heating_minuti_da_ultimo_cambio
        unit_of_measurement: "min"
        state_class: measurement
        state: >-
          {% set entity_id = 'switch.4_ch_interrutore_3' %}
          {% set ent = states.get(entity_id) %}
          {% if ent is none or ent.last_changed is none or ent.state in ['unknown', 'unavailable'] %}
            unknown
          {% else %}
            {{ ((as_timestamp(now()) - as_timestamp(ent.last_changed)) / 60) | round(1) }}
          {% endif %}

      # Etichetta stato target (include override, manuale e logica auto)
      - name: "Heating — target state (label)"
        unique_id: heating_target_state_label
        object_id: heating_target_state_label
        state: >-
          {% if is_state('input_boolean.heating_manual_active', 'on') %}
            MANUALE {{ states('input_select.heating_manual_mode') }}
          {% elif is_state('input_boolean.heating_force_on', 'on') %}
            FORZATO ON
          {% elif is_state('input_boolean.heating_force_off', 'on') %}
            FORZATO OFF
          {% elif is_state('binary_sensor.heating_should_run', 'on') %}
            AUTO = ON
          {% else %}
            AUTO = OFF
          {% endif %}

  - binary_sensor:
      # --------------------------
      # BLOCCO: Finestra oraria + meteo
      # --------------------------
      - name: "Heating — finestra oraria"
        unique_id: heating_window
        object_id: heating_finestra_oraria
        availability: >-
          {{ state_attr('input_datetime.heating_window_start', 'timestamp') is not none
             and state_attr('input_datetime.heating_window_end', 'timestamp') is not none }}
        state: >-
          {% set s = state_attr('input_datetime.heating_window_start', 'timestamp') %}
          {% set e = state_attr('input_datetime.heating_window_end', 'timestamp') %}
          {% set nowt = now().hour * 3600 + now().minute * 60 + now().second %}
          {% set st = (s % 86400) | int %}
          {% set et = (e % 86400) | int %}
          {% if st == et %}
            true   {# finestra "sempre" se orari uguali #}
          {% elif st < et %}
            {{ st <= nowt <= et }}
          {% else %}
            {{ nowt >= st or nowt <= et }}
          {% endif %}

      - name: "Heating — esterna fredda"
        unique_id: heating_ext_cold
        object_id: heating_esterna_fredda
        availability: >-
          {{ states('sensor.t_out') not in ['unknown', 'unavailable', '']
             and states('input_number.heating_ext_cold_threshold') not in ['unknown', 'unavailable', ''] }}
        state: >-
          {% set th = states('input_number.heating_ext_cold_threshold') | float(16) %}
          {{ states('sensor.t_out') | float(99) <= th }}

      # --------------------------
      # BLOCCO: Necessità termica
      # --------------------------
      - name: "Heating — almeno una stanza sotto target"
        unique_id: heating_need_temp
        object_id: heating_almeno_una_stanza_sotto_target
        availability: >-
          {{ states('sensor.heating_rooms_below_target') not in ['unknown', 'unavailable'] }}
        state: >-
          {{ (states('sensor.heating_rooms_below_target') | int(0)) > 0 }}

      - name: "Heating — richiesta automatica"
        unique_id: heating_auto_need
        object_id: heating_richiesta_automatica
        icon: mdi:robot
        state: >-
          {{
            is_state('input_boolean.heating_enable', 'on')
            and is_state('binary_sensor.heating_finestra_oraria', 'on')
            and is_state('binary_sensor.heating_esterna_fredda', 'on')
            and is_state('binary_sensor.heating_almeno_una_stanza_sotto_target', 'on')
          }}

      # --------------------------
      # BLOCCO: Lock tempi minimo ON/OFF
      # --------------------------
      - name: "Heating — lock MIN ON ok"
        unique_id: heating_lock_min_on_ok
        object_id: heating_lock_min_on_ok
        state: >-
          {% set sw = 'switch.4_ch_interrutore_3' %}
          {% set ent = states.get(sw) %}
          {% set min_on = states('input_number.heating_min_on_minutes') | float(30) %}
          {% if ent is none or ent.state in ['unknown', 'unavailable'] %}
            false
          {% elif ent.state == 'on' %}
            {{ (as_timestamp(now()) - as_timestamp(ent.last_changed)) / 60 >= min_on }}
          {% else %}
            true
          {% endif %}

      - name: "Heating — lock MIN OFF ok"
        unique_id: heating_lock_min_off_ok
        object_id: heating_lock_min_off_ok
        state: >-
          {% set sw = 'switch.4_ch_interrutore_3' %}
          {% set ent = states.get(sw) %}
          {% set min_off = states('input_number.heating_min_off_minutes') | float(30) %}
          {% if ent is none or ent.state in ['unknown', 'unavailable'] %}
            false
          {% elif ent.state == 'off' %}
            {{ (as_timestamp(now()) - as_timestamp(ent.last_changed)) / 60 >= min_off }}
          {% else %}
            true
          {% endif %}

      # --------------------------
      # BLOCCO: Decisione finale (rispetta override + lock)
      # --------------------------
      - name: "Heating Should Run"
        unique_id: heating_should_run
        object_id: heating_should_run
        availability: "true"
        device_class: heat
        icon: mdi:radiator
        state: >-
          {% set force_on = is_state('input_boolean.heating_force_on', 'on') %}
          {% set force_off = is_state('input_boolean.heating_force_off', 'on') %}
          {% set base_need = is_state('binary_sensor.heating_richiesta_automatica', 'on') %}
          {% set sw_on = is_state('switch.4_ch_interrutore_3', 'on') %}
          {% if force_on %}
            true
          {% elif force_off %}
            false
          {% else %}
            {% if sw_on %}
              {{ base_need or not is_state('binary_sensor.heating_lock_min_on_ok', 'on') }}
            {% else %}
              {{ base_need and is_state('binary_sensor.heating_lock_min_off_ok', 'on') }}
            {% endif %}
          {% endif %}

# ---------------------------------------------------------------------------
# SENSORI STATISTICI — Ore ON oggi/ieri
# ---------------------------------------------------------------------------
sensor:
  - platform: history_stats
    name: "Riscaldamento — Ore ON oggi"
    unique_id: heating_hours_on_today
    entity_id: switch.4_ch_interrutore_3
    state: "on"
    type: time
    start: "{{ today_at('00:00') }}"
    end: "{{ now() }}"

  - platform: history_stats
    name: "Riscaldamento — Ore ON ieri"
    unique_id: heating_hours_on_yesterday
    entity_id: switch.4_ch_interrutore_3
    state: "on"
    type: time
    start: "{{ (today_at('00:00') - timedelta(days=1)) }}"
    end: "{{ today_at('00:00') }}"

# ---------------------------------------------------------------------------
# SCRIPT
# ---------------------------------------------------------------------------
script:
  heating_clear_overrides:
    alias: "Heating — reset override"
    sequence:
      - service: input_boolean.turn_off
        target: { entity_id: input_boolean.heating_force_on }
      - service: input_boolean.turn_off
        target: { entity_id: input_boolean.heating_force_off }
      - service: timer.cancel
        target: { entity_id: timer.heating_manual_timeout }

# ---------------------------------------------------------------------------
# AUTOMAZIONI
# ---------------------------------------------------------------------------
automation:
  # --------------------------
  # Decision loop — applica heating_should_run allo switch generale
  # --------------------------
  - id: heating_decision_loop
    alias: "Heating — loop decisionale (1 min + variazioni)"
    mode: restart
    trigger:
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id:
          - binary_sensor.heating_should_run
          - binary_sensor.heating_richiesta_automatica
          - binary_sensor.heating_finestra_oraria
          - binary_sensor.heating_esterna_fredda
          - binary_sensor.heating_almeno_una_stanza_sotto_target
          - binary_sensor.heating_lock_min_on_ok
          - binary_sensor.heating_lock_min_off_ok
          - input_boolean.heating_enable
          - input_boolean.heating_force_on
          - input_boolean.heating_force_off
          - input_boolean.heating_use_giorno
          - input_boolean.heating_use_notte1
          - input_boolean.heating_use_notte2
          - input_boolean.heating_use_bagno
          - sensor.t_out
          - sensor.t_in_giorno
          - sensor.t_in_notte1
          - sensor.t_in_notte2
          - sensor.t_in_bagno
    action:
      - choose:
          - conditions: "{{ is_state('binary_sensor.heating_should_run', 'on') }}"
            sequence:
              - service: switch.turn_on
                target: { entity_id: switch.4_ch_interrutore_3 }
          - conditions: "{{ is_state('binary_sensor.heating_should_run', 'off') }}"
            sequence:
              - service: switch.turn_off
                target: { entity_id: switch.4_ch_interrutore_3 }
        default: []

  # --------------------------
  # Gestione modalità manuale: attiva override per durata timer
  # --------------------------
  - id: heating_manual_handler
    alias: "Heating — gestione modalità manuale"
    mode: restart
    trigger:
      - platform: state
        entity_id:
          - input_boolean.heating_manual_active
          - input_select.heating_manual_mode
      - platform: event
        event_type: timer.finished
        event_data:
          entity_id: timer.heating_manual_timeout
    action:
      - choose:
          # Timer scaduto → torno in automatico
          - conditions: "{{ trigger.platform == 'event' }}"
            sequence:
              - service: input_boolean.turn_off
                target: { entity_id: input_boolean.heating_manual_active }
              - service: script.heating_clear_overrides

          # Manuale attivo → set del timer e forzatura ON/OFF
          - conditions:
              - condition: state
                entity_id: input_boolean.heating_manual_active
                state: "on"
            sequence:
              - service: timer.start
                target: { entity_id: timer.heating_manual_timeout }
              - service: script.heating_clear_overrides
              - choose:
                  - conditions: "{{ states('input_select.heating_manual_mode') == 'ON' }}"
                    sequence:
                      - service: input_boolean.turn_on
                        target: { entity_id: input_boolean.heating_force_on }
                  - conditions: "{{ states('input_select.heating_manual_mode') == 'OFF' }}"
                    sequence:
                      - service: input_boolean.turn_on
                        target: { entity_id: input_boolean.heating_force_off }

          # Manuale disattivato manualmente → pulizia override
          - conditions:
              - condition: state
                entity_id: input_boolean.heating_manual_active
                state: "off"
            sequence:
              - service: script.heating_clear_overrides
        default: []

  # --------------------------
  # Log giornaliero: salva le ore ON di ieri nell'helper
  # --------------------------
  - id: heating_log_hours_daily
    alias: "Heating — scrivi ore ON di ieri nell'helper giornaliero"
    trigger:
      - platform: time
        at: "00:05:00"
    action:
      - service: input_number.set_value
        target:
          entity_id: input_number.heating_hours_on_daily
        data:
          value: "{{ states('sensor.heating_hours_on_yesterday') | float(0) }}"
