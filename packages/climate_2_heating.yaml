---
###############################################################################
# climate_2_heating.yaml  Modulo riscaldamento a pavimento (2025)
# Dipendenze: sensori base da climate_0_sensors.yaml (t_in_*, t_out, t_in_med)
# KPI chiave esposti:
# - sensor.heating_priority / sensor.heating_reason
# - binary_sensor.heating_should_run (comando logico)
# - binary_sensor.heating_lock_min_on_ok / binary_sensor.heating_lock_min_off_ok
# - binary_sensor.heating_finestra_oraria / binary_sensor.heating_esterna_fredda
###############################################################################
# NOTE ANALISI ENTITÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ (normalizzazione 2025-02)
# - Canonical OK: tutti gli helpers e sensori definiti coincidono con README_sensori_clima.md.
# - Normalizzati: nessuno (nessun alias legacy presente).
# - Rimossi: nessuno (nessun helper inutilizzato individuato in questa revisione).
# - Dipendenze esterne: binary_sensor.surplus_ok (modulo energia/surplus).

homeassistant:
  customize:
    switch.4_ch_interrutore_3:
      friendly_name: "Riscaldamento - Interruttore Generale"
      icon: mdi:radiator
      # NOTA: rele hardware invertito (state ON = circuito disattivo, OFF = attivo)

###############################################################################
# 1) HELPERS  abilitazioni, modalitÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â , setpoint
###############################################################################
input_boolean:  # Inclusione delle stanze nel controllo
  heating_use_giorno:
    name: "Heating - Usa zona giorno"
    icon: mdi:home
  heating_use_notte1:
    name: "Heating - Usa zona notte 1"
    icon: mdi:bed
  heating_use_notte2:
    name: "Heating - Usa zona notte 2"
    icon: mdi:bed

  heating_use_bagno:
    name: "Heating  Usa bagno"
    icon: mdi:shower

  # Abilitazione generale e override manuale
  heating_enable:
    name: "Heating  Abilita logica"
    icon: mdi:radiator
  heating_manual_active:
    name: "Heating  ModalitÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â  manuale attiva"
    icon: mdi:hand-back-right

input_select:
  heating_manual_mode:
    name: "Heating ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ModalitÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â  manuale"
    options:
      - off
      - eco
      - comfort
      - boost
    icon: mdi:tune-variant

input_number:
  temp_target_risc:
    name: "Heating  Setpoint comfort"
    min: 18
    max: 23
    step: 0.1
    unit_of_measurement: "Ãƒâ€šÃ‚Â°C"
    icon: mdi:home-thermometer
  heating_setpoint_night:
    name: "Heating  Setpoint night setback"
    min: 15
    max: 21
    step: 0.1
    unit_of_measurement: "Ãƒâ€šÃ‚Â°C"
    icon: mdi:weather-night
  heating_hysteresis:
    name: "Heating  Isteresi"
    min: 0.2
    max: 1.5
    step: 0.1
    unit_of_measurement: "Ãƒâ€šÃ‚Â°C"
    icon: mdi:axis-x-arrow
  heating_antifreeze_threshold:
    name: "Heating  Soglia antigelo"
    min: 5
    max: 15
    step: 0.5
    unit_of_measurement: "Ãƒâ€šÃ‚Â°C"
    icon: mdi:snowflake-alert
  heating_ext_cold_threshold:
    name: "Heating  Esterna fredda"
    min: -10
    max: 10
    step: 0.5
    unit_of_measurement: "Ãƒâ€šÃ‚Â°C"
    icon: mdi:thermometer-minus
  heating_boost_delta:
    name: "Heating  Delta boost FV"
    min: 0
    max: 1.0
    step: 0.1
    unit_of_measurement: "Ãƒâ€šÃ‚Â°C"
    icon: mdi:flash
  heating_min_on_minutes:
    name: "Heating  Min ON"
    min: 5
    max: 180
    step: 5
    unit_of_measurement: "min"
    icon: mdi:timer-play
  heating_min_off_minutes:
    name: "Heating  Min OFF"
    min: 5
    max: 180
    step: 5
    unit_of_measurement: "min"
    icon: mdi:timer-off
  heating_hours_on_daily:
    name: "Heating  Ore ON (snapshot)"
    unit_of_measurement: "h"
    min: 0
    max: 24
    step: 0.1
    icon: mdi:timeline-clock

input_datetime:
  heating_window_start:
    name: "Heating Ã¢â‚¬â€ Fascia start"
    has_time: true
    has_date: false
  heating_window_end:
    name: "Heating Ã¢â‚¬â€ Fascia end"
    has_time: true
    has_date: false

###############################################################################
# 2) TIMER
###############################################################################
timer:
  heating_manual_timeout:
    name: "Heating  Timeout manuale"
    duration: "01:00:00"

###############################################################################
# 3) TEMPLATE SENSOR  KPI logici
###############################################################################
template:
  - sensor: # Elenco stanze attive
      - name: "Heating  stanze attive"
        unique_id: heating_rooms_active
        state: >-
          {% set rooms = [
            ('Zona Giorno', 'sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
            ('Notte1', 'sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
            ('Notte2', 'sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
            ('Bagno', 'sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
          ] %}
          {% set labels = [] %}
          {% for label, sid, flag in rooms %}
            {% if is_state(flag, 'on') %}
              {% set labels = labels + [label] %}
            {% endif %}
          {% endfor %}
          {{ labels | length }}
        attributes:
          rooms: >-
            {% set rooms = [
              ('Zona Giorno', 'sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
              ('Notte1', 'sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
              ('Notte2', 'sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
              ('Bagno', 'sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
            ] %}
            {% set labels = [] %}
            {% for label, sid, flag in rooms %}
              {% if is_state(flag, 'on') %}
                {% set labels = labels + [label] %}
              {% endif %}
            {% endfor %}
            {{ labels | join(', ') if labels | length > 0 else 'Nessuna' }}

      # Temperatura minima delle stanze abilitate
      - name: "Heating  T interna minima"
        unique_id: heating_t_in_min
        unit_of_measurement: "Ãƒâ€šÃ‚Â°C"
        device_class: temperature
        state_class: measurement
        icon: mdi:thermometer-low
        state: >-
          {% set invalid = ['unknown', 'unavailable', '', 'none', 'None'] %}
          {% set zones = [
              ('sensor.t_in_giorno',  'input_boolean.heating_use_giorno'),
              ('sensor.t_in_notte1',  'input_boolean.heating_use_notte1'),
              ('sensor.t_in_notte2',  'input_boolean.heating_use_notte2'),
              ('sensor.t_in_bagno',   'input_boolean.heating_use_bagno')
          ] %}
          {% set temps = [] %}
          {% for s, flag in zones %}
            {% if is_state(flag, 'on') and states(s) not in invalid %}
              {% set v = states(s)|float(default=none) %}
              {% if v is not none %}
                {% set temps = temps + [v] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {% if temps | length > 0 %}
            {{ (temps|min) | round(1) }}
          {% else %}
            {# fallback: use average indoor temperature #}
            {% set t_med = states('sensor.t_in_med') %}
            {% if t_med not in invalid %}
              {{ t_med|float | round(1) }}
            {% else %}
              unknown
            {% endif %}
          {% endif %}

      # Conteggio stanze sotto target comfort
      - name: "Heating  stanze sotto target"
        unique_id: heating_rooms_below_target
        state: >-
          {% set comfort = states('input_number.temp_target_risc') | float(21) %}
          {% set hyst = states('input_number.heating_hysteresis') | float(0.3) %}
          {% set rooms = [
            ('sensor.t_in_giorno', 'input_boolean.heating_use_giorno'),
            ('sensor.t_in_notte1', 'input_boolean.heating_use_notte1'),
            ('sensor.t_in_notte2', 'input_boolean.heating_use_notte2'),
            ('sensor.t_in_bagno', 'input_boolean.heating_use_bagno')
          ] %}
          {% set count = 0 %}
          {% for sid, flag in rooms %}
            {% if is_state(flag, 'on') and states(sid) not in ['unknown','unavailable',''] %}
              {% if states(sid) | float < comfort - hyst %}
                {% set count = count + 1 %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ count }}

      # Errori sensore zona giorno
      - name: "Heating  errore zona giorno"
        unique_id: heating_error_zona_giorno
        state: >-
          {% set v = states('sensor.t_in_giorno') %}
          {% if v in ['unknown','unavailable',''] %}
            sensor_missing
          {% elif (v | float) < 5 or (v | float) > 35 %}
            out_of_range
          {% else %}
            ok
          {% endif %}

      # Errori sensori zona notte (include notte1/notte2)
      - name: "Heating  errore zona notte"
        unique_id: heating_error_zona_notte
        state: >-
          {% set vals = [states('sensor.t_in_notte1'), states('sensor.t_in_notte2')] %}
          {% set valid = vals | reject('in', ['unknown','unavailable','']) | map('float') | list %}
          {% if valid | length == 0 %}
            sensor_missing
          {% elif (valid | min) < 5 or (valid | max) > 35 %}
            out_of_range
          {% else %}
            ok
          {% endif %}

      # Minuti da ultimo cambio stato del relÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¨ fisico (considerando inversione)
      - name: "Heating  minuti da ultimo cambio"
        unique_id: heating_minutes_since_change
        unit_of_measurement: "min"
        state: >-
          {% set ent = states.switch['4_ch_interrutore_3'] if 'switch.4_ch_interrutore_3' in states.switch else none %}
          {% if ent is none %}
            unknown
          {% else %}
            {{ ((as_timestamp(now()) - as_timestamp(ent.last_changed)) / 60) | round(1) }}
          {% endif %}

      # Reason & priority complessiva
      - name: "Heating  reason"
        unique_id: heating_reason
        state: >-
          {% if is_state('binary_sensor.heating_failsafe_sensors_bad','on') %}
            P0_failsafe
          {% elif is_state('input_boolean.heating_manual_active','on') %}
            manual_{{ states('input_select.heating_manual_mode') }}
          {% else %}
            {% set comfort = states('input_number.temp_target_risc') | float(21) %}
            {% set hyst = states('input_number.heating_hysteresis') | float(0.3) %}
            {% set night_sp = states('input_number.heating_setpoint_night') | float(18.5) %}
            {% set anti = states('input_number.heating_antifreeze_threshold') | float(8) %}
            {% set boost = states('input_number.heating_boost_delta') | float(0.3) %}
            {% set tmin = states('sensor.heating_t_in_min') | float(default=none) %}
            {% set tout = states('sensor.t_out') | float(default=none) %}
            {% set window_comfort = is_state('binary_sensor.heating_finestra_oraria','on') %}
            {% set pv_hook = is_state('binary_sensor.surplus_ok','on') %}
            {% set enable = is_state('input_boolean.heating_enable','on') %}

            {% if tmin is none %}
              sensors_unavailable
            {% elif tmin < anti or (tout is number and tout < states('input_number.heating_ext_cold_threshold')|float(2)) %}
              P1_anti_frost
            {% elif enable and tmin < comfort - hyst and (window_comfort or (comfort - tmin) >= 1.0) %}
              P2_comfort
            {% elif enable and window_comfort and pv_hook and tmin <= comfort - boost %}
              P3_pv_boost
            {% elif enable and not window_comfort and tmin < night_sp - hyst %}
              P4_night_setback
            {% else %}
              idle
            {% endif %}
          {% endif %}
        attributes:
          priority: >-
            {% set r = this.state %}
            {% if r.startswith('P0') or r == 'sensors_unavailable' %}
              P0_failsafe
            {% elif r.startswith('P1') %}
              P1_anti_frost
            {% elif r.startswith('P2') %}
              P2_comfort
            {% elif r.startswith('P3') %}
              P3_pv_boost
            {% elif r.startswith('P4') %}
              P4_night_setback
            {% elif r.startswith('manual') %}
              manual
            {% elif r == 'idle' %}
              idle
            {% else %}
              idle
            {% endif %}

          action: >-
            {% set r = this.state %}
            {% if r == 'P0_failsafe' or r == 'sensors_unavailable' %}off{% elif r.startswith('manual_off') %}off{% elif r == 'idle' %}off{% else %}on{% endif %}
          reason: "{{ this.state }}"

      - name: "Heating  priority"
        unique_id: heating_priority
        state: >-
          {% set pr = state_attr('sensor.heating_reason','priority') %}
          {{ pr if pr is not none else 'idle' }}

  - binary_sensor: # Failsafe: sensori mancanti o fuori range
      - name: "Heating  failsafe sensori"
        unique_id: heating_failsafe_sensors_bad
        device_class: problem
        state: >-
          {% set temps = [
            states('sensor.t_in_giorno'),
            states('sensor.t_in_notte1'),
            states('sensor.t_in_notte2'),
            states('sensor.t_in_bagno'),
            states('sensor.t_out')
          ] %}
          {% set valid = temps | reject('in', ['unknown','unavailable','']) | list %}
          {% if valid | length != temps | length %}
            true
          {% else %}
            {% set vals = temps | map('float') | list %}
            {% if vals | select('lt', -20) | list | length > 0 %}
              true
            {% elif vals | select('gt', 45) | list | length > 0 %}
              true
            {% else %}
              false
            {% endif %}
          {% endif %}

      # Finestra di funzionamento comfort (default 10:00ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦16:00)
      - name: "Heating  finestra oraria"
        unique_id: heating_finestra_oraria
        state: >-
          {% set start = states('input_datetime.heating_window_start') %}
          {% set end = states('input_datetime.heating_window_end') %}
          {% if start in ['unknown','unavailable',''] %}
            {% set start = '10:00:00' %}
          {% endif %}
          {% if end in ['unknown','unavailable',''] %}
            {% set end = '16:00:00' %}
          {% endif %}
          {% set s_time = strptime(start, '%H:%M:%S') %}
          {% set e_time = strptime(end, '%H:%M:%S') %}
          {% set now_t = now().time() %}
          {{ s_time.time() <= now_t <= e_time.time() }}

      # Alias PV: finestra + hook surplus
      - name: "Heating  finestra PV"
        unique_id: heating_window_pv
        state: >-
          {{ is_state('binary_sensor.heating_finestra_oraria','on') and is_state('binary_sensor.surplus_ok','on') }}

      # Finestra notte (fuori fascia comfort)
      - name: "Heating  finestra notte"
        unique_id: heating_window_night
        state: >-
          {{ not is_state('binary_sensor.heating_finestra_oraria','on') }}

      # Esterna fredda (supporto antifreeze)
      - name: "Heating  esterna fredda"
        unique_id: heating_esterna_fredda
        state: >-
          {% set tout = states('sensor.t_out') %}
          {% if tout in ['unknown','unavailable',''] %}
            false
          {% else %}
            {{ tout | float <= states('input_number.heating_ext_cold_threshold') | float(2) }}
          {% endif %}

      # Almeno una stanza sotto target
      - name: "Heating  almeno una stanza sotto target"
        unique_id: heating_almeno_una_stanza_sotto_target
        state: >-
          {{ states('sensor.heating_rooms_below_target') | int(0) > 0 }}

      # Lock anti-ciclo min OFF
      - name: "Heating  lock min OFF ok"
        unique_id: heating_lock_min_off_ok
        state: >-
          {% set mins = states('input_number.heating_min_off_minutes') | float(30) %}
          {% set runtime = states('sensor.heating_minutes_since_change') | float(default=0) %}
          {% set relay_on = is_state('switch.heating_master','on') %}
          {{ relay_on or runtime >= mins }}

      # Lock anti-ciclo min ON
      - name: "Heating  lock min ON ok"
        unique_id: heating_lock_min_on_ok
        state: >-
          {% set mins = states('input_number.heating_min_on_minutes') | float(15) %}
          {% set runtime = states('sensor.heating_minutes_since_change') | float(default=0) %}
          {% set relay_on = is_state('switch.heating_master','on') %}
          {{ (not relay_on) or runtime >= mins }}

      # Comando logico finale
      - name: "Heating  should run"
        unique_id: heating_should_run
        state: >-
          {% if is_state('binary_sensor.heating_failsafe_sensors_bad','on') %}
            false
          {% else %}
            {% set desired = state_attr('sensor.heating_reason','action') %}
            {% set relay_on = is_state('switch.heating_master','on') %}
            {% if desired == 'on' %}
              {{ relay_on or is_state('binary_sensor.heating_lock_min_off_ok','on') }}
            {% else %}
              {% if relay_on and is_state('binary_sensor.heating_lock_min_on_ok','off') %}
                true
              {% else %}
                false
              {% endif %}
            {% endif %}
          {% endif %}

  - switch: - name: "Riscaldamento  comando"
        unique_id: heating_master
        default_entity_id: switch.heating_master
        icon: mdi:radiator
        turn_on: - service: switch.turn_off
            target: entity_id: switch.4_ch_interrutore_3
        turn_off: - service: switch.turn_on
            target: entity_id: switch.4_ch_interrutore_3
        state: "{{ not is_state('switch.4_ch_interrutore_3','on') }}" # MODIFICATA

      - name: "Riscaldamento  blocco notturno"
        unique_id: heating_night_block
        default_entity_id: switch.heating_night_block
        icon: mdi:power
        turn_on: - service: switch.turn_on
            target: entity_id: switch.4_ch_interrutore_3
        turn_off: - service: switch.turn_off
            target: entity_id: switch.4_ch_interrutore_3
        state: "{{ is_state('switch.4_ch_interrutore_3','on') }}"

###############################################################################
# 4) SENSORI STATISTICI  runtime storico
###############################################################################
sensor: - platform: history_stats
    name: "Riscaldamento  Ore ON oggi"
    unique_id: heating_hours_on_today
    entity_id: switch.4_ch_interrutore_3
    state: "off"
    type: time
    start: "{{ today_at('00:00') }}"
    end: "{{ now() }}"

  - platform: history_stats
    name: "Riscaldamento  Ore ON ieri"
    unique_id: heating_hours_on_yesterday
    entity_id: switch.4_ch_interrutore_3
    state: "off"
    type: time
    start: "{{ (today_at('00:00') - timedelta(days=1)) }}"
    end: "{{ today_at('00:00') }}"

###############################################################################
# 6) SCRIPT DI SUPPORTO
###############################################################################
script: ###############################################################################
# 7) AUTOMAZIONI
###############################################################################
automation: # Gestione timeout manuale
  - id: heating_manual_timeout
    alias: "HEATING  timeout manuale"
    triggers: - trigger: state
        entity_id: input_boolean.heating_manual_active
        to: "on"
      - trigger: event
        event_type: timer.finished
        event_data: entity_id: timer.heating_manual_timeout
    actions: - choose: - conditions: - condition: state
                entity_id: input_boolean.heating_manual_active
                state: "on"
            sequence: - service: timer.start
                target: { entity_id: timer.heating_manual_timeout }
          - conditions: - condition: event
                event_type: timer.finished
            sequence: - service: input_boolean.turn_off
                target: { entity_id: input_boolean.heating_manual_active }

  # Attuazione comando logico
  - id: heating_drive_master
    alias: "HEATING  attua should_run"
    mode: restart
    triggers: - trigger: state
        entity_id: - binary_sensor.heating_should_run
          - switch.heating_master
      - trigger: state
        entity_id: - input_boolean.heating_manual_active
          - input_select.heating_manual_mode
    actions: - choose: - conditions: - condition: state
                entity_id: binary_sensor.heating_should_run
                state: "on"
            sequence: - service: switch.turn_on
                target: { entity_id: switch.heating_master }
          - conditions: - condition: state
                entity_id: binary_sensor.heating_should_run
                state: "off"
            sequence: - condition: state
                entity_id: binary_sensor.heating_lock_min_on_ok
                state: "on"
              - service: switch.turn_off
                target: { entity_id: switch.heating_master }

# ENTITY MAP STATUS (heating)
# - All entity_id aligned with logica/core/README_sensori_clima.md
# - No unused helpers except optional diagnostics listed in README
# - External dependencies: binary_sensor.surplus_ok (PV surplus)
